(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{400:function(t,s,a){"use strict";a.r(s);var n=a(97),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"prototype-委托设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype-委托设计模式"}},[t._v("#")]),t._v(" prototype 委托设计模式")]),t._v(" "),a("p",[t._v("委托模式，不同于类的继承\n类理论：\n定义一个父类，添加各种各样的functions，可以包括所有子类的方法。\n接着指定子类，他们都会继承该父类，然后可能各自添加一些特殊的独有的function\n此外，类模式鼓励重写父类的方法。")]),t._v(" "),a("p",[t._v("委托：\n先建立一个对象，（该对象不是类也不能叫函数，但我们都会喜欢称呼为构造函数），\n他也会包含所有真正实例使用的方法，因为实例可以通过prototype链使用。\n对于真正的每个实例，js会建立具体的对象，用以存储特定的数据和funs，该对象通过委托，\n能够使用“构造函数”上的方法。")]),t._v(" "),a("p",[t._v("委托方式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setPrototypeOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("委托中，尽量避免使用容易被重写的函数，类中则鼓励")]),t._v(" "),a("p",[t._v("委托又可以分为 对象委托 和 原型风格 的两种")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("区别：")]),t._v(" "),a("ul",[a("li",[t._v("原型这种，需要new() 以及 初始化给参数放在一起")]),t._v(" "),a("li",[t._v("而对象关联这种，可以分开这两部步骤，可能更合适一些场景。")])]),t._v(" "),a("p",[t._v("对象关联可以让代码看起来更简洁。\n例子：\n1 建造对象\n2 关联对象\n就拥有了所关联对象的方法 委托调用。\n无需实例化，因为他们不是类，只用Object.create() 关联一个新对象即可。\n或者Object.setPrototypeOf(bar, foo) 即可。")]),t._v(" "),a("p",[t._v("ES6 的class 更加简洁。")]),t._v(" "),a("h3",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[t._v("#")]),t._v(" summary")]),t._v(" "),a("p",[t._v("行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系")])])}),[],!1,null,null,null);s.default=e.exports}}]);